#!/bin/bash

# use_server: If you're running our whisper server
#             (ie. cd server-flask && flask run)
#             Set to 0 to disable, and we'll run whisper directly
use_server=0
use_server=1
server_host=localhost
server_port=5000

################################################################
# The following are not used by this script if you are using
# the server (ie. if use_server=1 above), because that's
# configured at the server

	# whisper_model: Examples from my whisper -h output:
	#  tiny.en,tiny,base.en,base,small.en,small,medium.en,medium,
	#    large-v1,large-v2,large
	whisper_model=base
	#whisper_lang_opts=()
	whisper_lang_opts=(--language en)  # This can be empty

	# envact: Script to activate environment.
	#         THIS IS NOT USED IF YOU'RE USING THE SERVER, BECAUSE
	#         WE AREN'T USING PYTHON FROM THIS SCRIPT UNLESS WE'RE
	#         RUNNING WHISPER DIRECTLY.
	#         This means, if you have use_server=1 above, you can
	#         ignore these lines.
	envact=~/venv/whisper/bin/activate
	# envpattern: Regex used to test the python path so we don't have
	#             to re-init the env if we're in it
	#     if ! which python3 | grep "$envpattern" >/dev/null; then
	envpattern=venv/whisper


################################################################
# Now we're back at things that affect us regardless of server
# mode or not...

# You can pick a different record command for your system.
# Note: Whisper will convert anything you give it to
#   its needed   16000 Hz, s16le, mono
record_command () { arecord -f S16_LE -r 16000 "$1"; }
# sox's 'rec' has a strange delay on my system
# record_command () { rec "$1"; }


################################################################
################################################################
################################################################
# Unless you're developing, you probably don't need to
# change anything below

# dd: desktop dir: used for icons we rename for status
#     (and usually to run these scripts)
dd=~/Desktop

bin_wauto=whisper-auto
bin_wkill=whisper-kill-rec

cachedir=cache

stat_done='WH-Done'
stat_rec='WH-Rec'
stat_wh='WH-Whispering'
kill_name="End Rec"

# Initital renaming
rename_first_match () {
	local src_base="$1"
	local target="$2"
	local files=("$1"*)
	[[ -e "${files[0]}" ]] && mv "${files[0]}" "$target"
}
# ls -l "$dd/$bin_wauto"*
rename_first_match "$dd/$bin_wauto" "$dd/$stat_done"
rename_first_match "$dd/$bin_wkill" "$dd/$kill_name"

ourdir="$(dirname "$(readlink -f "$0")")"
. ./ansi.sh
if [[ $use_server = 0 ]]; then
	if ! which python3 | grep "$envpattern" >/dev/null; then
		echo "Not in whisper venv. Activating now..."
		. "$envact"
		[[ $? > 0 ]] && {
			echo "Couldn't activate env:\n$envact";
			exit;
		}
	fi
fi

cd "$ourdir" || { echo "Error"; exit 1; }
[[ -d $cachedir ]] || mkdir -p $cachedir ||
	{ echo "Error"; exit 1; }
wav="$cachedir/new.wav"
wavprior="$cachedir/new-prior.wav"
output="$cachedir/new.txt"
outputprior="$cachedir/new-prior.txt"
log="$cachedir/whisper.log"
[[ -a $wav ]] && mv "$wav" "$wavprior"
[[ -a $output ]] && mv "$output" "$outputprior"

set_status () {
	str="$1"
	files=($dd/WH-*)
	[[ -e ${files[0]} ]] && mv "${files[0]}" $dd/"$str"
}
set_status "$stat_rec"
record_command "$wav"
set_status "$stat_wh"

copy_output_to_clipboard () {
	cat "$output" | sed -e 's/^/   /; s/$/  	/;' | tr '\r\n' ' ' |
		awk '{$1=$1};1' | tr -d '\r\n' |  xsel -i -b
	echo " ^ Copied to clipboard"
}

if [[ $use_server = 0 ]]; then
	echo "Running whisper..."
	whisper --model "$whisper_model" --task transcribe \
		"${whisper_lang_opts[@]}" \
		--output_dir "$cachedir" \
		--output_format txt \
		"$wav" &>"$log"
	echo "Done."
	if [[ -f $outputx ]]; then
		echo " ${brede}Output not created?$rste"
	else
		echo "File '$output' created:"
		echo "  $(ls -lgG "$output")"
		printf "Result:\n ${yele}%s$rste\n" "$(cat "$output")"
		copy_output_to_clipboard
	fi
else
	result=$(curl -s -F file=@"$wav" $server_host:$server_port)
	printf "Result:\n ${yele}%s$rste\n" "$result"
	echo "Storing in file $output"
	printf '%s\n' "$result" > "$output"
	copy_output_to_clipboard
fi

set_status "$stat_done"
